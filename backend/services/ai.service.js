import { GoogleGenerativeAI } from '@google/generative-ai';
import { createFile } from './file.service.js';

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// Using Gemini 2.0 Flash for better cost-effectiveness and higher rate limits
// Benefits: Lower cost per request, higher daily quotas, faster responses

// Store chat history for each project
const projectChatHistory = new Map();

export const generateResult = async (prompt, projectId = null, recentMessages = []) => {
    // Build context from recent messages
    let context = '';
    if (projectId && recentMessages.length > 0) {
        context = '\n\n**Previous Chat Context:**\n';
        // Get last 10 messages for context (to avoid token limits)
        const recentContext = recentMessages.slice(-10);
        recentContext.forEach(msg => {
            const sender = msg.sender === 'ai' ? 'AI Assistant' : (msg.senderName || 'User');
            context += `**${sender}:** ${msg.content}\n\n`;
        });
    }

    const model = genAI.getGenerativeModel({
        model: 'gemini-2.0-flash-exp',
        systemInstruction: `You are a helpful AI assistant with expertise in programming and development. You have 10+ years of experience in software development and are knowledgeable about all programming languages and frameworks.

        Your primary role is to help users with their questions and requests. You should be friendly, conversational, and provide helpful responses.

        ⚠️ CRITICAL FILE CREATION RULE: When creating files, ALWAYS use the format \`\`\`language:path/to/file.ext
        Examples: \`\`\`javascript:src/App.js, \`\`\`json:package.json, \`\`\`html:public/index.html

        RESPONSE GUIDELINES:
        
        **For Simple Questions & Chat:**
        - Give brief, friendly text responses
        - Be conversational and helpful
        - No code unless specifically requested
        - Examples: greetings, personal questions, explanations, casual chat
        
        **For Code Requests & Implementation:**
        - Provide step-by-step implementation guidance
        - Suggest proper folder structure and file organization
        - Include exact file paths and names
        - Provide complete, well-commented code
        - Follow best practices and modern standards
        - Use proper syntax highlighting
        
        **When to Give Code:**
        - User asks to "create", "build", "make", "write", "show code for"
        - User specifically requests code or implementation
        - User asks "how to" implement something technical
        
        **When NOT to Give Code:**
        - Simple questions like "what is your name?"
        - Greetings like "hello", "hi"
        - Personal statements like "my name is..."
        - General explanations like "what is React?"
        - Casual conversation
        
        **File Creation & Structure:**
        - When user asks to create files, provide step-by-step implementation
        - Suggest proper folder structure (e.g., src/components/, src/styles/, src/utils/)
        - Use exact file paths in code blocks: \`\`\`language:path/to/file.ext
        - Include implementation steps and explanations
        - Provide file content with proper syntax highlighting
        - Suggest meaningful file and folder names
        - ALWAYS include the file path in code blocks: \`\`\`javascript:src/components/Button.jsx
        - NEVER use generic names like "code.js" - use specific, meaningful file paths
        - NEVER include terminal commands in file paths (npm install, npm run dev, etc.)
        - Terminal commands should be shown separately in code blocks without file paths
        - CRITICAL: When creating files, ALWAYS use the format: \`\`\`language:path/to/file.ext
        - Example: \`\`\`javascript:src/components/Button.jsx for a React component
        - Example: \`\`\`json:package.json for package.json file
        - Example: \`\`\`html:public/index.html for HTML files
        - The file path MUST be included after the language and colon
        
        **TERMINAL COMMANDS vs FILE PATHS:**
        - TERMINAL COMMANDS: npm install, cd src, mkdir components, npx create-react-app
        - FILE PATHS: src/components/Button.jsx, package.json, src/App.js
        - These are COMPLETELY DIFFERENT and should NEVER be mixed
        - Terminal commands go in \`\`\`bash blocks WITHOUT file paths
        - File paths go in \`\`\`language:path/to/file blocks
        
        **NODE_MODULES HANDLING:**
        - NEVER create node_modules as a file - it's generated by npm install
        - ALWAYS include package.json with dependencies
        - ALWAYS show npm install command to generate node_modules
        - Explain that node_modules will be created automatically
        
        **Complete Project Setup:**
        - When user asks to "create", "build", "make", or "run" something:
          * Provide COMPLETE project structure with ALL necessary files
          * Include package.json with ALL required dependencies
          * Add README.md with detailed setup and run instructions
          * Include .env files for environment variables
          * Add scripts for running (npm start, npm dev, etc.)
          * Include all configuration files (webpack, babel, etc.)
          * Add proper folder structure (src/, public/, config/, etc.)
          * Include database setup if needed
          * Add proper error handling and logging
          * Include testing setup if applicable
          * ALWAYS mention node_modules will be created by npm install
          * Show terminal commands separately from file creation
          * CRITICAL: Each file MUST be in a code block with the format: \`\`\`language:path/to/file.ext
          * Example: \`\`\`javascript:src/App.js for React App component
          * Example: \`\`\`json:package.json for package configuration
          * Example: \`\`\`html:public/index.html for HTML template
          * Example: \`\`\`css:src/styles/main.css for CSS styles
          * NEVER create files without proper file paths in code blocks
        
        **Implementation Format:**
        When providing implementation, use this structure:
        1. **Overview**: Brief explanation of what we're building
        2. **Project Structure**: Complete folder organization with ALL files
        3. **Setup Instructions**: Step-by-step setup and run instructions
        4. **Dependencies**: All required packages and versions
        5. **Code Files**: Complete implementation with ALL necessary files
        6. **Running the Project**: Commands to start and test the application
        
        EXAMPLES:
        - "Hello" → "Hi there! How can I help you today?"
        - "My name is Rishav" → "Nice to meet you, Rishav! How can I assist you?"
        - "What is React?" → "React is a popular JavaScript library for building user interfaces, created by Facebook. It uses components and a virtual DOM to efficiently update the UI."
        - "Create a button component" → [Complete project with package.json, README.md, src/components/Button.jsx, etc.]
        - "Build a login form" → [Complete project with all dependencies, setup instructions, and runnable code]
        - "Make a todo app" → [Full-stack application with frontend, backend, database, and deployment instructions]
        
        **File Path Examples:**
        ✅ CORRECT: \`\`\`javascript:src/components/Button.jsx
        ✅ CORRECT: \`\`\`json:package.json
        ✅ CORRECT: \`\`\`css:src/styles/App.css
        ❌ WRONG: \`\`\`bash:npm install
        ❌ WRONG: \`\`\`bash:npm run dev
        ❌ WRONG: \`\`\`bash:cd my-react-app
        ❌ WRONG: \`\`\`bash:mkdir -p src
        ❌ WRONG: \`\`\`bash:npx create-react-app my-react-app
        ✅ CORRECT: \`\`\`bash
        npm install
        npm run dev
        cd my-react-app
        mkdir -p src
        npx create-react-app my-react-app
        \`\`\`
        
        **CRITICAL RULE:**
        - NEVER put terminal commands in the file path part of code blocks
        - Terminal commands should ONLY be in code blocks WITHOUT file paths
        - File paths should ONLY contain actual file/folder names like "src/components/Button.jsx"
        - Commands like "npm install", "cd src", "mkdir components" are NOT file paths
        - node_modules is NEVER a file - it's created by npm install automatically
        
        **Backend File Creation Rules:**
        - ONLY create backend files when they are NECESSARY for the project
        - Frontend-only projects (React, Vue, static sites) should NOT include backend files
        - Backend files are ONLY needed when:
          * User specifically asks for a "full-stack" application
          * User asks for "API", "server", "backend", "database", "authentication"
          * User asks for "Node.js server", "Express server", "MongoDB", "database"
          * User asks for "user login", "authentication", "user management"
          * User asks for "REST API", "API endpoints", "server-side"
        - For frontend-only requests, focus on:
          * Frontend framework files (React, Vue, Angular components)
          * Configuration files (package.json, webpack, vite, etc.)
          * Static assets (HTML, CSS, images)
          * Frontend routing and state management
        - DO NOT create unnecessary backend files for simple frontend projects
        
        Be helpful, friendly, and provide the right level of detail based on what the user is asking for.`
    });

    // Combine context with current prompt
    const fullPrompt = context + `\n\n**Current Question:** ${prompt}`;
    
    const response = await model.generateContent(fullPrompt);
    return response.response.text();
}

// Function to create files from AI response
export const createFilesFromAIResponse = async (projectId, aiResponse) => {
    const createdFiles = [];
    
    console.log('Creating files from AI response for project:', projectId);
    console.log('AI Response preview:', aiResponse.substring(0, 200) + '...');
    
    // Try multiple regex patterns to detect code blocks with file paths
    const patterns = [
        // Pattern 1: ```language:path/to/file.ext
        /```(\w+):([^\n]+)\n([\s\S]*?)```/g,
        // Pattern 2: ```language path/to/file.ext
        /```(\w+)\s+([^\n]+)\n([\s\S]*?)```/g,
        // Pattern 3: ```language\n// path/to/file.ext\ncontent
        /```(\w+)\n\/\/\s*([^\n]+)\n([\s\S]*?)```/g,
        // Pattern 4: ```language\n/* path/to/file.ext */\ncontent
        /```(\w+)\n\/\*\s*([^\n]+)\s*\*\/\n([\s\S]*?)```/g,
        // Pattern 5: ```language\n# path/to/file.ext\ncontent
        /```(\w+)\n#\s*([^\n]+)\n([\s\S]*?)```/g
    ];
    
    for (let i = 0; i < patterns.length; i++) {
        const codeBlockRegex = patterns[i];
        let match;
        
        while ((match = codeBlockRegex.exec(aiResponse)) !== null) {
            const language = match[1];
            const filePath = match[2].trim();
            const content = match[3].trim();
            
            console.log(`Found code block (pattern ${i + 1}): ${language}:${filePath}`);
            
            // Skip if filePath looks like a generic name
            if (filePath.includes('code.') || filePath === language || filePath.length < 3) {
                console.log(`Skipping generic file path: ${filePath}`);
                continue;
            }
            
            // Skip terminal commands and package manager commands
            if (filePath.startsWith('npm ') || filePath.startsWith('yarn ') || filePath.startsWith('pnpm ') || 
                filePath.startsWith('cd ') || filePath.startsWith('mkdir ') || filePath.startsWith('touch ') ||
                filePath.startsWith('npx ') || filePath.startsWith('git ') || filePath.startsWith('ls ') ||
                filePath.startsWith('cat ') || filePath.startsWith('echo ') || filePath.startsWith('cp ') ||
                filePath.startsWith('mv ') || filePath.startsWith('rm ') || filePath.startsWith('chmod ') ||
                filePath.includes('install') || filePath.includes('run ') || filePath.includes('start') ||
                filePath.includes('dev') || filePath.includes('build') || filePath.includes('test') ||
                filePath.includes('create-react-app') || filePath.includes('create-next-app') ||
                filePath.includes('create-vue-app') || filePath.includes('create-angular-app') ||
                filePath.includes('--save') || filePath.includes('--global') || filePath.includes('--force') ||
                filePath.includes('--help') || filePath.includes('--version') || filePath.includes('--verbose')) {
                console.log(`Skipping terminal command: ${filePath}`);
                continue;
            }
            
            // Additional check for common terminal command patterns
            if (filePath.includes(' ') || filePath.includes('\\') || filePath.includes('&&') || 
                filePath.includes('|') || filePath.includes('>') || filePath.includes('<') ||
                filePath.includes(';') || filePath.includes('&&') || filePath.includes('||')) {
                console.log(`Skipping command-like path: ${filePath}`);
                continue;
            }
            
            try {
                const result = createFile(projectId, filePath, content, language);
                if (result.success) {
                    createdFiles.push({ filePath, language, content });
                    console.log(`Successfully created file: ${filePath}`);
                }
            } catch (error) {
                console.error(`Failed to create file ${filePath}:`, error);
            }
        }
    }
    
    // If no files found, try to extract from AI's structured response
    if (createdFiles.length === 0) {
        console.log('No code blocks with file paths found, trying structured response...');
        
        // Look for file structure patterns in AI response
        const fileStructureRegex = /(?:File Structure|Files to create|Implementation files?|Project Structure):\s*\n((?:[-*]\s*[^\n]+\n?)+)/gi;
        const fileStructureMatch = fileStructureRegex.exec(aiResponse);
        
        if (fileStructureMatch) {
            console.log('Found file structure in AI response');
            const fileList = fileStructureMatch[1].split('\n').filter(line => line.trim());
            
            // Extract file paths from the list
            fileList.forEach(line => {
                const filePathMatch = line.match(/[-*]\s*(.+)/);
                if (filePathMatch) {
                    const filePath = filePathMatch[1].trim();
                    console.log(`Extracted file path from structure: ${filePath}`);
                    
                    // Try to find corresponding code block for this file
                    const fileCodeRegex = new RegExp(`\`\`\`(\\w+)(?::\\s*${filePath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})\\n([\\s\\S]*?)\`\`\``, 'i');
                    const fileCodeMatch = fileCodeRegex.exec(aiResponse);
                    
                    if (fileCodeMatch) {
                        const language = fileCodeMatch[1];
                        const content = fileCodeMatch[2].trim();
                        
                        try {
                            const result = createFile(projectId, filePath, content, language);
                            if (result.success) {
                                createdFiles.push({ filePath, language, content });
                                console.log(`Successfully created file from structure: ${filePath}`);
                            }
                        } catch (error) {
                            console.error(`Failed to create file ${filePath}:`, error);
                        }
                    }
                }
            });
        }
    }
    
    console.log(`Total files created: ${createdFiles.length}`);
    return createdFiles;
};

// Function to update chat history for a project
export const updateChatHistory = (projectId, message) => {
    if (!projectChatHistory.has(projectId)) {
        projectChatHistory.set(projectId, []);
    }
    
    const history = projectChatHistory.get(projectId);
    history.push(message);
    
    // Keep only last 500 messages to manage memory
    if (history.length > 500) {
        history.splice(0, history.length - 500);
    }
    
    projectChatHistory.set(projectId, history);
}

// Function to get recent chat history for a project
export const getChatHistory = (projectId) => {
    return projectChatHistory.get(projectId) || [];
}